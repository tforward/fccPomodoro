{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/olooElem.js","webpack:///./src/scripts/script.js","webpack:///./src/scripts/olooObserver.js","webpack:///./src/scripts/olooEvent.js","webpack:///./node_modules/tocktimer/tock.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","e","ElementDelegator","proto","Element","elemId","type","this","elem","document","createElement","id","gc","init","getElementById","console","log","items","forEach","item","initElemObjects","ids","delegator","objs","obj","push","Tock","myBase","myApp","Subscribe","subscribe","addItems","unsubscribe","broadcast","func","args","keys","length","formattedDisplayTime","num","displayTime","getformatSessionLength","upperLimit","limit","lowerLimit","script_reset","timer","currentTime","stop","textContent","startBtn","start_stop","toggle","className","clockDial","posClock","timeLength","final_time","setBreakLength","breakNum","setSessionLength","getBreakLength","parseInt","getSessionLength","clock","session","pos","time","documentElement","style","setProperty","ButtonDelegator","Button","setup","timeMMSS","str","formatted","substring","updateTime","msToTimecode","lap","switchSession","timerLbl","state","initNewTimer","circleTime","timelength","getTimer","start","play","countdown","interval","callback","complete","initApplication","labels","buttons","btn","eventSandbox","Event","initEvent","eventType","Array","isArray","assign","addEvent","options","boundFunc","boundOptions","addEventListener","removeEvent","removeEventListener","tags","target","currentTarget","indexOf","tagName","main","self","numBreak","startTime","timeToMS","pause","onreadystatechange","readyState","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","Date","now","Function","ctx","slice","arguments","fn","apply","_tick","duration_ms","go","clearTimeout","timeout","diff","start_time","next_interval_in","missed_ticks","Math","floor","abs","setTimeout","_startCountdown","duration","_startTimer","start_offset","MILLISECONDS_RE","MM_SS_RE","MM_SS_ms_OR_HH_MM_SS_RE","yyyy_mm_dd_HH_MM_SS_ms_RE","instances","pause_time","reset","msToTime","ms","milliseconds","zeroPad","seconds","input","toString","show_ms","minutes","test","String","time_split","match","date","split","setYear","setMonth","setDate","setHours","setMinutes","setSeconds","setMilliseconds","max","getTime","parse","isNaN"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// ======================================================================\r\n// Element Delegator\r\n// ======================================================================\r\n\r\nexport function ElementDelegator(proto = null) {\r\n  // This is the base Delegator \"Class\" for a element\r\n  // By default does not inherirt the proto chain from another object\r\n  const Element = Object.create(proto);\r\n  // Use \"create\" for creating a new element\r\n  Element.create = function create(elemId, type) {\r\n    this.elem = document.createElement(type);\r\n    this.elem.id = elemId;\r\n    this.id = elemId;\r\n    Element.gc([\"init\", \"create\"]);\r\n  };\r\n  // Use \"init\" when working with an existing element\r\n  Element.init = function init(elemId) {\r\n    this.id = elemId;\r\n    this.elem = document.getElementById(this.id);\r\n    if (this.elem === null) {\r\n      console.log(`Init Error: No element with id \"${this.id}\"`);\r\n    }\r\n    // After creation garbage collected init/create\r\n    Element.gc([\"init\", \"create\"]);\r\n  };\r\n  // Garbage Collect\r\n  Element.gc = function gc(items) {\r\n    items.forEach(item => {\r\n      delete Element[item];\r\n    });\r\n    // Delete gc itself\r\n    delete Element.gc;\r\n  };\r\n  return Element;\r\n}\r\n\r\n// ======================================================================\r\n// Delegated Element Utilities\r\n// ======================================================================\r\n\r\nexport function initElemObjects(ids, delegator, proto = null) {\r\n  // Used for quickly initiating Element delegated objects\r\n  // Can accept another proto delegator\r\n  const objs = [];\r\n  let obj;\r\n  ids.forEach(id => {\r\n    if (proto === null) {\r\n      obj = delegator();\r\n    } else {\r\n      obj = delegator(proto());\r\n    }\r\n    obj.init(id);\r\n    objs.push(obj);\r\n  });\r\n  return objs;\r\n}\r\n\r\nexport function FragmentDelegator(proto = null) {\r\n  const Fragment = Object.create(proto);\r\n\r\n  Fragment.initFragment = function initFragment() {\r\n    this.fragment = document.createDocumentFragment();\r\n  };\r\n  Fragment.addNodes = function addNodes(items) {\r\n    items.forEach(item => this.fragment.appendChild(item.elem));\r\n  };\r\n  return Fragment;\r\n}\r\n","\"use strict\";\r\n\r\nimport css_ from \"../css/styles.css\";\r\nimport { EventDelegator, getTargetId } from \"./olooEvent\";\r\nimport { SubscribersDelegator } from \"./olooObserver\";\r\nimport { ElementDelegator, initElemObjects } from \"./olooElem\";\r\n\r\nconst Tock = require(\"tocktimer\");\r\n\r\nconst myBase = Object.create(null);\r\n\r\nconst myApp = SubscribersDelegator();\r\n\r\nmyBase.initApplication = function init() {\r\n  myApp.init();\r\n  addElements();\r\n  const eventSandbox = EventDelegator();\r\n  eventSandbox.initEvent(\"eventSandbox\", \"click\", { tags: [\"BUTTON\", \"I\"] });\r\n  eventSandbox.addEvent(eventController);\r\n  myApp.state = -1;\r\n\r\n  function eventController(args, e) {\r\n    // Only Passes events of with tagNames defined in the array\r\n    const id = getTargetId(e, args.tags);\r\n    if (id !== undefined) {\r\n      myBase.main(id);\r\n    }\r\n  }\r\n};\r\n\r\nmyBase.main = function main(id) {\r\n  const self = myApp.obj[id];\r\n  let num = getSessionLength();\r\n  let numBreak = getBreakLength();\r\n\r\n  if (id === \"start_stop\") {\r\n    startStop(self);\r\n  } else if (id === \"session-increment\") {\r\n    num = upperLimit(num);\r\n    setSessionLength(num);\r\n    formattedDisplayTime(num);\r\n    reset();\r\n  } else if (id === \"session-decrement\") {\r\n    num = lowerLimit(num);\r\n    setSessionLength(num);\r\n    formattedDisplayTime(num);\r\n    reset(num);\r\n  } else if (id === \"break-increment\") {\r\n    numBreak = upperLimit(numBreak);\r\n    setBreakLength(numBreak);\r\n  } else if (id === \"break-decrement\") {\r\n    numBreak = lowerLimit(numBreak);\r\n    setBreakLength(numBreak);\r\n  } else if (id === \"reset\") {\r\n    reset();\r\n    setSessionLength(25);\r\n    formattedDisplayTime(25);\r\n    setBreakLength(5);\r\n  }\r\n};\r\n\r\nfunction formattedDisplayTime(num) {\r\n  const mmss = getformatSessionLength(num);\r\n  displayTime(mmss);\r\n}\r\n\r\nfunction upperLimit(num) {\r\n  let limit = num;\r\n  if (limit >= 60) {\r\n    return limit;\r\n  }\r\n  limit += 1;\r\n  return limit;\r\n}\r\n\r\nfunction lowerLimit(num) {\r\n  let limit = num;\r\n  if (limit <= 1) {\r\n    return limit;\r\n  }\r\n  limit -= 1;\r\n  return limit;\r\n}\r\n\r\nfunction reset() {\r\n  if (myApp.timer !== undefined) {\r\n    resetBeep();\r\n    myApp.timer.stop();\r\n    myApp.obj[\"time-left\"].elem.textContent = getformatSessionLength();\r\n    const startBtn = myApp.obj[\"start_stop\"];\r\n    startBtn.toggle = -1;\r\n    startBtn.elem.className = \"fas fa-play-circle\";\r\n    clockDial(0, 0);\r\n  }\r\n}\r\n\r\nfunction startStop(obj) {\r\n  const self = obj;\r\n  if (self.toggle === -1) {\r\n    // Init Start\r\n    myApp.timer = getTimer();\r\n    self.toggle = 1;\r\n    self.elem.className = \"fas fa-pause-circle\";\r\n    const startTime = timer();\r\n    myApp.timer.start(startTime);\r\n    myApp.state = 1;\r\n  } else if (self.toggle === 1) {\r\n    // Pause\r\n    self.toggle = 0;\r\n    myApp.timer.pause();\r\n    self.elem.className = \"fas fa-play-circle\";\r\n    if (myApp.state === 1) {\r\n      posClock(getSessionLength());\r\n    } else if (myApp.state === 0) {\r\n      posClock(getBreakLength());\r\n    }\r\n  } else {\r\n    // Start\r\n    self.toggle = 1;\r\n    // Unpause\r\n    myApp.timer.pause();\r\n    self.elem.className = \"fas fa-pause-circle\";\r\n    clockDial(60, myApp.timer.final_time * 0.001);\r\n  }\r\n}\r\n\r\nfunction posClock(timeLength) {\r\n  const pausedTime = myApp.timer.final_time * 0.001;\r\n  const x = pausedTime / 60;\r\n  const b = timeLength - x;\r\n  const c = timeLength / b;\r\n  const d = 60 / c;\r\n  clockDial(d, 0);\r\n}\r\n\r\nfunction setBreakLength(breakNum) {\r\n  myApp.obj[\"break-length\"].elem.textContent = breakNum;\r\n}\r\n\r\nfunction setSessionLength(num) {\r\n  myApp.obj[\"session-length\"].elem.textContent = num;\r\n}\r\n\r\nfunction getBreakLength() {\r\n  const sessionAsStr = parseInt(myApp.obj[\"break-length\"].elem.textContent, 10);\r\n  return sessionAsStr;\r\n}\r\n\r\nfunction getSessionLength() {\r\n  const sessionAsStr = parseInt(myApp.obj[\"session-length\"].elem.textContent, 10);\r\n  return sessionAsStr;\r\n}\r\n\r\nfunction timer() {\r\n  const session = getformatSessionLength();\r\n  const startTime = myApp.timer.timeToMS(session);\r\n\r\n  // Get the time in mins and convert to seconds\r\n  const sessionLengthSecs = myApp.obj[\"session-length\"].elem.textContent * 60;\r\n  clockDial(60, sessionLengthSecs);\r\n  return startTime;\r\n}\r\n\r\nfunction clockDial(clock, session) {\r\n  setClockDisplay(clock);\r\n  setTimeDuration(session);\r\n}\r\n\r\nfunction addElements() {\r\n  const labelIds = [\"timer-label\", \"break-length\", \"session-length\", \"time-left\", \"circleTime\"];\r\n\r\n  const btnIds = [\r\n    \"break-decrement\",\r\n    \"break-increment\",\r\n    \"session-decrement\",\r\n    \"session-increment\",\r\n    \"start_stop\",\r\n    \"reset\"\r\n  ];\r\n\r\n  const labels = initElemObjects(labelIds, ElementDelegator);\r\n  const buttons = initElemObjects(btnIds, ButtonDelegator, ElementDelegator);\r\n\r\n  // Run the setup function on each button\r\n  buttons.forEach(btn => btn.setup());\r\n\r\n  myApp.addItems(labels);\r\n  myApp.addItems(buttons);\r\n}\r\n\r\nfunction ButtonDelegator(proto = null) {\r\n  const Button = Object.create(proto);\r\n\r\n  Button.setup = function setup() {\r\n    this.toggle = -1;\r\n  };\r\n  return Button;\r\n}\r\n\r\nfunction getformatSessionLength() {\r\n  const sessionAsStr = getSessionLength();\r\n  return `${sessionAsStr}:00`;\r\n}\r\n\r\nfunction displayTime(timeMMSS) {\r\n  const str = `${timeMMSS}`;\r\n  const pad = \"00000\";\r\n  const formatted = pad.substring(0, pad.length - str.length) + str;\r\n  myApp.obj[\"time-left\"].elem.textContent = formatted;\r\n}\r\n\r\nfunction updateTime() {\r\n  const currentTime = myApp.timer.msToTimecode(myApp.timer.lap());\r\n  const timeMMSS = currentTime.substring(3, 8);\r\n  displayTime(timeMMSS);\r\n}\r\n\r\nfunction switchSession() {\r\n  const timerLbl = myApp.obj[\"timer-label\"];\r\n  if (myApp.state === 1) {\r\n    timerLbl.elem.textContent = \"Break\";\r\n    myApp.state = 0;\r\n    initNewTimer(getBreakLength());\r\n    myApp.obj[\"circleTime\"].elem.className = \"break\";\r\n  } else if (myApp.state === 0) {\r\n    timerLbl.elem.textContent = \"Session\";\r\n    myApp.obj[\"circleTime\"].elem.className = \"working\";\r\n    myApp.state = 1;\r\n    initNewTimer(getSessionLength());\r\n  }\r\n}\r\n\r\nfunction playBeep() {\r\n  const beep = document.getElementById(\"beep\");\r\n  beep.play();\r\n}\r\n\r\nfunction resetBeep() {\r\n  const beep = document.getElementById(\"beep\");\r\n  beep.currentTime = 0;\r\n}\r\n\r\nfunction initNewTimer(timelength) {\r\n  const time = timelength * 60000;\r\n  myApp.timer = getTimer();\r\n  myApp.timer.start(time);\r\n\r\n  playBeep();\r\n  if (myApp.state === 1) {\r\n    clockDial(60, getSessionLength() * 60);\r\n  } else if (myApp.state === 0) {\r\n    clockDial(0, getBreakLength() * 60);\r\n  }\r\n  myApp.obj[\"start_stop\"].toggle = 1;\r\n}\r\n\r\nfunction getTimer() {\r\n  const newTimer = new Tock({\r\n    countdown: true,\r\n    interval: 250,\r\n    callback: updateTime,\r\n    complete: switchSession\r\n  });\r\n  return newTimer;\r\n}\r\n\r\nfunction setClockDisplay(pos) {\r\n  // Range 0 - 60, 15 is a quarter\r\n  document.documentElement.style.setProperty(\"--pos\", `${pos}vmin`);\r\n}\r\n\r\nfunction setTimeDuration(time) {\r\n  // in seconds\r\n  document.documentElement.style.setProperty(\"--time\", `${time}s`);\r\n}\r\n\r\n// ======================================================================\r\n// Handler when the DOM is fully loaded\r\ndocument.onreadystatechange = function onreadystatechange() {\r\n  if (document.readyState === \"complete\") {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n      console.log(\"*** RUNNING IN DEV MODE! ***\");\r\n    }\r\n    myBase.initApplication();\r\n  } else {\r\n    // Do something during loading (optional)\r\n  }\r\n};\r\n// ======================================================================\r\n","// ======================================================================\r\n// Observer Delegator Pattern\r\n// ======================================================================\r\n\r\nexport function SubscribersDelegator() {\r\n  const Subscribe = Object.create(null);\r\n\r\n  Subscribe.init = function init() {\r\n    this.obj = Object.create(null);\r\n    delete Subscribe.init;\r\n  };\r\n  Subscribe.subscribe = function subscribe(item) {\r\n    this.obj[item.id] = item;\r\n  };\r\n  // Use addItems when you want to subscribe many items\r\n  Subscribe.addItems = function addItems(items) {\r\n    items.forEach(item => Subscribe.subscribe(item));\r\n  };\r\n  Subscribe.unsubscribe = function unsubscribe(items) {\r\n    // Can unsubscribe one observer, or an array of observers\r\n    if (typeof items === \"string\") {\r\n      const item = items;\r\n      delete this.obj[item];\r\n    } else {\r\n      items.forEach(key => delete this.obj[key]);\r\n    }\r\n  };\r\n  Subscribe.broadcast = function broadcast(func, ...args) {\r\n    // On each object called func\r\n    // Any additional args will get passed into the func\r\n    // define them just using comma seperator\r\n    const keys = Object.keys(this.obj);\r\n    for (let i = 0; i < keys.length; i += 1) {\r\n      this.obj[keys[i]][func](...args);\r\n    }\r\n  };\r\n  return Subscribe;\r\n}\r\n\r\n// ======================================================================\r\n// Observer Delegator Utilities\r\n// ======================================================================\r\n\r\nexport function createObserversById(subscriber, ids, delegator) {\r\n  ids.forEach(elemId => {\r\n    const elem = document.getElementById(elemId);\r\n    const observer = delegator();\r\n    observer.init(elemId, elem);\r\n    subscriber.subscribe(observer);\r\n  });\r\n}\r\n","// ======================================================================\r\n// OOLO Event Sandbox Delegator Utilities\r\n//\r\n// Creating a new sandbox based on element ID's\r\n//\r\n// Import Script\r\n// import { EventDelegator, getTargetId } from \"./olooEvent\";\r\n//\r\n// # Instantiate Delegator\r\n//  const eventSandbox = EventDelegator();\r\n// # Define Element by ID to attached Event sandbox to, types of event, and on what tags\r\n//  eventSandbox.initEvent(\"eventSandbox\", \"click\", { tags: [\"BUTTON\"] });\r\n//  For more Event types see: https://developer.mozilla.org/en-US/docs/Web/Events\r\n// # Call a function to handle the events ex. EventController Handles all events within the Event sandbox\r\n//    Note: EventController is just a function that's called\r\n//  eventSandbox.addEvent(eventController);\r\n//\r\n// Example Event Controller\r\n// function eventController(args, e) {\r\n//   // Only Passes events of with tagNames defined in the array\r\n//   const id = getTargetId(e, args.tags);\r\n//   if (id !== undefined) {\r\n//     const obj = myApp.elems[id];\r\n//   }\r\n// }\r\n// ======================================================================\r\n\r\nexport function EventDelegator() {\r\n  // Creates an Event object on the element\r\n  const Event = Object.create(null);\r\n\r\n  Event.initEvent = function setup(elemId, type, args) {\r\n    // The Element to bind the event handler too\r\n    this.elem = document.getElementById(elemId);\r\n    // The type of event ex: \"click\"\r\n    this.eventType = type;\r\n    // Additional arguments that will be passed to the bound function as an object\r\n    this.args = args;\r\n    // Helper: If Array convert to object\r\n    if (Array.isArray(args)) {\r\n      this.args = Object.assign({}, args);\r\n    }\r\n  };\r\n  Event.addEvent = function add(func, options) {\r\n    // func: Bound an Function to an Event\r\n    // (options): Optional parameter for passing options to event listener ex: \"once: true\"\r\n    this.boundFunc = func.bind(this.elem, this.args);\r\n    // this.bound prevents binding loss for arguments and options\r\n    this.boundOptions = options;\r\n    this.elem.addEventListener(this.eventType, this.boundFunc, this.boundOptions);\r\n  };\r\n  Event.removeEvent = function remove() {\r\n    // Remove the listener, do not have to pass the \"options\" since it is bound\r\n    this.elem.removeEventListener(this.eventType, this.boundFunc, this.boundOptions);\r\n  };\r\n  return Event;\r\n}\r\n\r\n// ======================================================================\r\n// Event Utilities\r\n// ======================================================================\r\n\r\nexport function getTargetId(e, tags) {\r\n  // Prevents events triggering on the parent element\r\n  if (e.target !== e.currentTarget) {\r\n    // Returns the target ID of event for allowed tags Ex: DIV, BUTTON etc.\r\n    if (tags.indexOf(e.target.tagName) > -1) {\r\n      return e.target.id;\r\n    }\r\n  }\r\n  // Returns undefined if no target match by ID\r\n  return undefined;\r\n}\r\n","/**\n* Tock by Mr Chimp - github.com/mrchimp/tock\n* Based on code by James Edwards:\n*    sitepoint.com/creating-accurate-timers-in-javascript/\n*/\n\n// Implements Date.now() for ie lt 9\nDate.now = Date.now || function() { return +new Date(); };\n\n// Polyfills Function.prototype.bind for IE lt 9 and Safari lt 5.1\nif ( typeof Function.prototype.bind != 'function' ) {\n    Function.prototype.bind = function (ctx) {\n        var args = Array.prototype.slice.call(arguments, 1),\n            fn = this;\n        return function () {\n            args.push.apply(args, arguments);\n            return fn.apply(ctx, args);\n        };\n    };\n}\n\n(function (root, factory) {\n  if ( typeof define === 'function' && define.amd ) {\n    define(factory);\n  } else if ( typeof exports === 'object' ) {\n    module.exports = factory();\n  } else {\n    root.Tock = factory();\n  }\n}(this, function () {\n\n  /**\n   * Called every tick for countdown clocks.\n   * i.e. once every this.interval ms\n   */\n  function _tick () {\n    this.time += this.interval;\n\n    if ( this.countdown && (this.duration_ms - this.time < 0) ) {\n      this.final_time = 0;\n      this.go = false;\n      this.callback(this);\n      clearTimeout(this.timeout);\n      this.complete(this);\n      return;\n    } else {\n      this.callback(this);\n    }\n\n    var diff = (Date.now() - this.start_time) - this.time,\n        next_interval_in = diff > 0 ? this.interval - diff : this.interval;\n\n    if ( next_interval_in <= 0 ) {\n      this.missed_ticks = Math.floor(Math.abs(next_interval_in) / this.interval);\n      this.time += this.missed_ticks * this.interval;\n\n      if ( this.go ) {\n        _tick.call(this);\n      }\n    } else if ( this.go ) {\n      this.timeout = setTimeout(_tick.bind(this), next_interval_in);\n    }\n  }\n\n  /**\n   * Called by Tock internally - use start() instead\n   */\n  function _startCountdown (duration) {\n    this.duration_ms = duration;\n    this.start_time = Date.now();\n    this.time = 0;\n    this.go = true;\n    _tick.call(this);\n  }\n\n  /**\n   * Called by Tock internally - use start() instead\n   */\n  function _startTimer (start_offset) {\n    this.start_time = start_offset || Date.now();\n    this.time = 0;\n    this.go = true;\n    _tick.call(this);\n  }\n\n  var MILLISECONDS_RE           = /^\\s*(\\+|-)?\\d+\\s*$/,\n      MM_SS_RE                  = /^(\\d{1,2}):(\\d{2})$/,\n      MM_SS_ms_OR_HH_MM_SS_RE   = /^(\\d{1,2}):(\\d{2})(?::|\\.)(\\d{2,3})$/,\n      MS_PER_HOUR               = 3600000,\n      MS_PER_MIN                = 60000,\n      MS_PER_SEC                = 1000,\n      /* The RegExp below will match a date in format `yyyy-mm-dd HH:MM:SS` and optionally with `.ms` at the end.\n       * It will also match ISO date string, i.e. if the whitespace separator in the middle is replaced with a `T`\n       * and the date string is also suffixed with a `Z` denoting UTC timezone.\n       */\n      yyyy_mm_dd_HH_MM_SS_ms_RE = /^(\\d{4})-([0-1]\\d)-([0-3]\\d)(?:\\s|T)(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{3})Z?)?$/;\n\n  var Tock = function (options) {\n    options = options || {};\n\n    if ( ! (this instanceof Tock) ) return new Tock(options);\n\n    Tock.instances = (Tock.instances || 0) + 1;\n\n    this.go           = false;\n    this.timeout      = null;\n    this.missed_ticks = null;\n    this.interval     = options.interval || 10;\n    this.countdown    = options.countdown || false;\n    this.start_time   = 0;\n    this.pause_time   = 0;\n    this.final_time   = 0;\n    this.duration_ms  = 0;\n    this.time         = 0;\n    this.callback     = options.callback || function () {};\n    this.complete     = options.complete || function () {};\n  };\n\n  /**\n   * Reset the clock\n   */\n  Tock.prototype.reset = function () {\n    if ( this.countdown ) {\n      return false;\n    }\n\n    this.stop();\n    this.start_time = 0;\n    this.time = 0;\n  };\n\n  /**\n   * Start the clock.\n   * @param {Various} time Accepts a single \"time\" argument\n   *   which can be in various forms:\n   *   - MM:SS\n   *   - MM:SS:ms or MM:SS.ms\n   *   - HH:MM:SS\n   *   - yyyy-mm-dd HH:MM:SS.ms\n   *   - milliseconds\n   */\n  Tock.prototype.start = function (time) {\n    if (this.go) return false;\n\n    time = time ? this.timeToMS(time) : 0;\n\n    this.start_time = time;\n    this.pause_time = 0;\n\n    if ( this.countdown ) {\n      _startCountdown.call(this, time);\n    } else {\n      _startTimer.call(this, Date.now() - time);\n    }\n  };\n\n  /**\n   * Stop the clock and clear the timeout\n   */\n  Tock.prototype.stop = function () {\n    this.pause_time = this.lap();\n    this.go = false;\n\n    clearTimeout(this.timeout);\n\n    if ( this.countdown ) {\n      this.final_time = this.duration_ms - this.time;\n    } else {\n      this.final_time = (Date.now() - this.start_time);\n    }\n  };\n\n  /**\n   * Stop/start the clock.\n   */\n  Tock.prototype.pause = function () {\n    if ( this.go ) {\n      this.pause_time = this.lap();\n      this.stop();\n    } else {\n      if ( this.pause_time ) {\n        if ( this.countdown ) {\n          _startCountdown.call(this, this.pause_time);\n        } else {\n          _startTimer.call(this, Date.now() - this.pause_time);\n        }\n\n        this.pause_time = 0;\n      }\n    }\n  };\n\n  /**\n   * Get the current clock time in ms.\n   * Use with Tock.msToTime() to make it look nice.\n   * @return {Integer} Number of milliseconds ellapsed/remaining\n   */\n  Tock.prototype.lap = function () {\n    if ( this.go ) {\n      var now;\n\n      if ( this.countdown ) {\n        now = this.duration_ms - (Date.now() - this.start_time);\n      } else {\n        now = (Date.now() - this.start_time);\n      }\n\n      return now;\n    }\n\n    return this.pause_time || this.final_time;\n  };\n\n  /**\n   * Format milliseconds as a MM:SS.ms string.\n   * @param  {Integer} ms Number of milliseconds\n   * @return {String}     String representation of ms in format MM:SS:ms\n   */\n  Tock.prototype.msToTime = function (ms) {\n    var milliseconds = this.zeroPad(ms % MS_PER_SEC, 3),\n        seconds = this.zeroPad(Math.floor((ms / MS_PER_SEC) % 60), 2),\n        minutes = this.zeroPad(Math.floor((ms / (MS_PER_MIN)) % 60), 2);\n\n    return minutes + ':' + seconds + '.' + milliseconds;\n  };\n\n  /**\n   * Pad the left side of a string with zeros up to a given length. I\n   * considered using an NPM package for this but it's probably best not to.\n   * @param  {Various} input  Number to pad. Will be converted to string.\n   * @param  {Integer} length Desired string length\n   * @return {String}         Padding number\n   */\n  Tock.prototype.zeroPad = function (input, length) {\n    input = input.toString();\n\n    while ( input.length < length ) {\n      input = '0' + input;\n    }\n\n    return input;\n  };\n\n  /**\n   * Format milliseconds as HH:MM:SS or HH:MM:SS:mmm\n   * @param  {Integer} ms      Number of milliseconds\n   * @param  {Boolean} show_ms If true, include milliseconds in output\n   * @return {String}          Formatted timecode string\n   */\n  Tock.prototype.msToTimecode = function (ms, show_ms) {\n    var seconds  = this.zeroPad(Math.floor((ms / MS_PER_SEC) % 60), 2),\n        minutes  = this.zeroPad(Math.floor((ms / MS_PER_MIN) % 60), 2),\n        hours    = this.zeroPad(Math.floor((ms / MS_PER_HOUR)), 2),\n        millisec = (show_ms ? ':' + this.zeroPad(Math.floor(ms % MS_PER_SEC), 3) : '');\n\n    return hours + ':' + minutes + ':' + seconds + millisec;\n  };\n\n  /**\n   * Convert a time string to milliseconds\n   *\n   * Possible inputs:\n   * MM:SS\n   * MM:SS:ms or MM:SS.ms\n   * HH:MM:SS\n   * yyyy-mm-dd HH:MM:SS.ms\n   *\n   * A milliseconds input will return it back for safety\n   * If the input cannot be recognized then 0 is returned\n   */\n  Tock.prototype.timeToMS = function (time) {\n    // If input is milliseconds integer then return it back\n    if ( MILLISECONDS_RE.test(String(time)) ) {\n      return time;\n    }\n\n    var ms,\n        time_split,\n        match,\n        date,\n        now = new Date();\n\n    if ( MM_SS_RE.test(time) ) { // If MM:SS\n      time_split = time.split(':');\n      ms = parseInt(time_split[0], 10) * MS_PER_MIN;\n      ms += parseInt(time_split[1], 10) * MS_PER_SEC;\n    } else {\n      match = time.match(MM_SS_ms_OR_HH_MM_SS_RE);\n\n      if ( match ) {\n        if ( match[3].length == 3 || parseInt(match[3], 10) > 59 ) { // If MM:SS:ms or MM:SS.ms (e.g. 10:10:458 or 10:10.458)\n          ms = parseInt(match[1], 10) * MS_PER_MIN;\n          ms += parseInt(match[2], 10) * MS_PER_SEC;\n          ms += parseInt(match[3], 10);\n        } else { // Then it's HH:MM:SS\n          ms = parseInt(match[1], 10) * MS_PER_HOUR;\n          ms += parseInt(match[2], 10) * MS_PER_MIN;\n          ms += parseInt(match[3], 10) * MS_PER_SEC;\n        }\n      } else if ( yyyy_mm_dd_HH_MM_SS_ms_RE.test(time) ) { // If yyyy-mm-dd HH:MM:SS or yyyy-mm-dd HH:MM:SS.ms or yyyy-mm-ddTHH:MM:SS.msZ\n        date = new Date();\n        now = new Date();\n\n        match = time.match(yyyy_mm_dd_HH_MM_SS_ms_RE);\n\n        date.setYear(match[1]);\n        date.setMonth(match[2]);\n        date.setDate(match[3]);\n        date.setHours(match[4]);\n        date.setMinutes(match[5]);\n        date.setSeconds(match[6]);\n\n        if (typeof match[7] !== 'undefined') {\n          date.setMilliseconds(match[7]);\n        }\n\n        ms = Math.max(0, date.getTime() - now.getTime());\n      } else {\n        // Let's try it as a date string\n        now = new Date();\n        ms = Date.parse(time);\n\n        if ( !isNaN(ms) ) { // Looks ok\n          ms = Math.max(0, ms - now.getTime());\n        } else { // Could not recognize input, so start from 0\n          ms = 0;\n        }\n      }\n    }\n\n    return ms;\n  };\n\n  return Tock;\n}));\n"],"sourceRoot":""}